form api

from django import forms

class ContactForm(forms.Form):
    error_css_class = 'error'
    required_css_class = 'required'
    subject = forms.CharField(max_length=100)
    message = forms.CharField(widget=forms.Textarea)
    sender = forms.EmailField()
    cc_myself = forms.BooleanField(required=False)

一个form实例,要么是绑定的,要么是非绑定的:
    一个非绑定的实例:>>> f = ContactForm()
    一个绑定的实例:  >>> data = {'subject': 'hello',
                    ...         'message': 'Hi there',
                    ...         'sender': 'foo@example.com',
                    ...         'cc_myself': True}
                    >>> f = ContactForm(data)
    Form.is_bound来判定是否绑定
    在Form实例中 的数据是不可更改的
    
使用form验证数据
 Form.clean():自定义验证数据方式,比如数据局域相互依赖
 Form.is_valid():Form对象验证数据的主函数,一个绑定的Form实例调用这个函数,返回是否验证成功
    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid email address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
 Form.errors:访问error属性,返回一个错误消息字典
    >>> f.errors
    {'sender': [u'Enter a valid email address.'], 'subject': [u'This field is required.']}
 form的数据会在第一次调用is_valid()方法,或第一次访问errors属性时被验证
 
 Form.errors.as_data():返回一个字典,映射数据区域的原始ValidationError实例,
    >>> f.errors.as_data()
    {'sender': [ValidationError(['Enter a valid email address.'])],
    'subject': [ValidationError(['This field is required.'])]}
    可以在view中重写错误信息,或自定义逻辑.或序列化错误消息.
 Form.errors.as_json(escape_html=False):返回序列化成JSON的错误消息
     >>> f.errors.as_json()
    {"sender": [{"message": "Enter a valid email address.", "code": "invalid"}],
    "subject": [{"message": "This field is required.", "code": "required"}]}
 Form.add_error(field, error):从view向Form实例中添加错误消息
    Form.add_error()自动清除cleand_data中保存的field的数据
 Form.non_field_errors():返回errors列表,不和特定field相关,

动态初始化数据
    Form.initial:声明一个field的值
        >>> f = ContactForm(initial={'subject': 'Hi there!'})
        可以在定义form类的时候使用,也可以在初始化form实例的时候使用

检查form的数据是否被更改
    Form.has_changed():
        表单被提交后,重构一个form,并附上初始值,就可以比较了
        >>> f = ContactForm(request.POST, initial=data)
        >>> f.has_changed()

访问form中的区域
    Form.fields
    f.fields.values()
    f.fields['name'].label = "Username"
    注意:不要更改base_fields属性,因为这回影响到后来的所有实例
        f.base_fields['name'].label = "Username"

访问"干净的"数据
    Form.cleaned_data
    每个Form类不仅要负责验证数据,还要清理数据,将数据转化成统一的格式.
    创建实例之后,并验证,就可以用cleaned_data来访问它
    cleaned_data中只包含被验证通过的数据.
    cleaned_data中不包含form类定义之外的field,并且包含所有定义的数据,即使为空
    
Form对象的第二个任务是渲染HTML
    渲染的HTML不包含table标签和submit按钮,需要自己完成
    每一个field对应一个HTML标签,CharField对应<input type='text'>,这些是默认值可以使用wedgets来修改
    HTML 的name取自Form类中field的定义
    每个field的文字标签也可以更改
    <label>中的id是'id_'前缀加field名字,
    
    其他输出形式:
        as_p():每个field包含在一个<p>标签中
        as_ul():每个field包含在一个<li>标签中
        as_table():默认调用这个

错误样式
Form.error_css_class
Form.required_css_class

配置form HTML元素id和<label>标签
    Form.auto_id:
        改变id的行为,True False string
        False:不渲染<label>标签
        True:渲染<label>标签,用field做id
        string:渲染<label>标签,用"xxx_%S"做标签
    Form.label_suffix:
        默认是":"

错误显示方式:
    作为一个<ul class="errorlist">在field附近输出错误
    自定义error列表的格式:
    >>> from django.forms.utils import ErrorList
    >>> class DivErrorList(ErrorList):
    ...     def __str__(self):              # __unicode__ on Python 2
    ...         return self.as_divs()
    ...     def as_divs(self):
    ...         if not self: return ''
    ...         return '<div class="errorlist">%s</div>' % ''.join(['<div class="error">%s</div>' % e for e in self])
    
    >>> f = ContactForm(data, auto_id=False, error_class=DivErrorList)
    >>> f.as_p()

更多的输出形式
    class BoundField:用来展示HTML或者访问Form实例的某个field的属性
    form['subject']
    for boundfield in form: print(boundfield)
    
    BoundField.errors:访问field的errors属性
    BoundField.label_tag(contents=None, attrs=None, label_suffix=None):访问field的label标签
        contents用来替换默认的标签内容
        attrs字典包含了label标签的其他属性
    BoundField.css_classes()
        更改class
    BoundField.value()
    BoundField.id_for_label

上传文件
表单继承

Form.prefix:表单前缀
    








 
